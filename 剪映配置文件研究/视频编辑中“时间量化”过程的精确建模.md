好的，明白了。您的要求非常清晰，这是对视频编辑中“时间量化”过程的精确建模。

当一个任意时长的视频被放到一个固定帧率的轨道上时，它的最终时长会被“量化”或“对齐”到整数帧的边界。这意味着映射后的新时长，必然是**单帧时长**的整数倍。

下面是修改后的 Node.js 函数。它会计算出视频占用的总帧数，然后基于这个帧数反推出它在剪映轨道上精确的、被量化后的时长（微秒）。

```javascript
/**
 * 根据视频的原始时长，计算其映射到30 FPS固定帧率轨道后的总帧数和新时长。
 *
 * @param {number} originalDurationInMicroseconds 视频的原始实际时长，单位是微秒。
 * @returns {{totalFrames: number, timelineDurationInMicroseconds: number}} 一个包含总帧数和在轨道上的新时长的对象。
 */
function calculateTimelineMetrics(originalDurationInMicroseconds) {
  // --- 参数校验 ---
  if (typeof originalDurationInMicroseconds !== 'number' || originalDurationInMicroseconds < 0) {
    console.error("输入错误: 时长必须是一个非负数字。");
    return {
      totalFrames: 0,
      timelineDurationInMicroseconds: 0
    };
  }

  // --- 定义常量 ---
  const FRAME_RATE = 30; // 剪映项目导出的固定帧率
  const MICROSECONDS_IN_A_SECOND = 1000000;

  // --- 步骤 1: 计算视频将占用的总帧数 ---
  // 核心逻辑：即使时长只超过前一帧一点点，也必须占用下一整个帧。
  // 这就是为什么我们使用 Math.ceil() 向上取整。
  const durationInSeconds = originalDurationInMicroseconds / MICROSECONDS_IN_A_SECOND;
  const rawFrameCount = durationInSeconds * FRAME_RATE;
  const totalFrames = Math.ceil(rawFrameCount);

  // 如果原始时长为0，则帧数也为0
  if (originalDurationInMicroseconds === 0) {
      return {
          totalFrames: 0,
          timelineDurationInMicroseconds: 0
      };
  }

  // --- 步骤 2: 基于总帧数，计算在轨道上的精确时长 ---
  // 轨道上的新时长 = 总帧数 * 每一帧的精确时长
  // 每一帧的精确时长 (微秒) = 1,000,000 / 30
  const singleFrameDuration = MICROSECONDS_IN_A_SECOND / FRAME_RATE;
  const newDuration = totalFrames * singleFrameDuration;
  
  // 最终的时长应该是整数，所以四舍五入到最接近的微秒
  const timelineDurationInMicroseconds = Math.round(newDuration);

  // --- 返回结果对象 ---
  return {
    totalFrames,
    timelineDurationInMicroseconds
  };
}


// --- 使用示例 ---

// 示例1: 您提供的第3帧的时间点 (100,000 微秒)
// 100,000 µs 正好是 3 帧 * (1,000,000 / 30) µs/帧
const metrics1 = calculateTimelineMetrics(100000);
console.log(`原始时长: 100,000 µs =>`, metrics1);
// 输出: { totalFrames: 3, timelineDurationInMicroseconds: 100000 }
// 这种情况下，原始时长刚好是帧时长的整数倍，所以映射后时长不变。

// 示例2: 一个不能被整除的时长 (90,000 微秒)
// 90,000µs / (1,000,000/30)µs/帧 = 2.7 帧。所以会占用 3 帧。
const metrics2 = calculateTimelineMetrics(90000);
console.log(`原始时长: 90,000 µs  =>`, metrics2);
// 输出: { totalFrames: 3, timelineDurationInMicroseconds: 100000 }
// 解释: 90,000微秒的时长不足以容纳3帧，但又超过2帧，所以它必须占用3个帧位，
// 导致它在轨道上的时长被“拉长”到完整的3帧时长，即100,000微秒。

// 示例3: 刚好1秒
const metrics3 = calculateTimelineMetrics(1000000);
console.log(`原始时长: 1,000,000 µs =>`, metrics3);
// 输出: { totalFrames: 30, timelineDurationInMicroseconds: 1000000 }

// 示例4: 比1秒多一点点
const metrics4 = calculateTimelineMetrics(1000001);
console.log(`原始时长: 1,000,001 µs =>`, metrics4);
// 输出: { totalFrames: 31, timelineDurationInMicroseconds: 1033333 }
// 解释: 多出的1微秒导致视频多占用了第31帧，所以其在轨道上的总时长变成了31帧的时长。

// 示例5: 一个长视频 (2分30秒550毫秒 = 150,550,000 微秒)
const metrics5 = calculateTimelineMetrics(150550000);
// 150.55 * 30 = 4516.5 -> 4517 frames
// 4517 * (1000000 / 30) = 150566666.66... -> 150566667
console.log(`原始时长: 150,550,000 µs =>`, metrics5);
// 输出: { totalFrames: 4517, timelineDurationInMicroseconds: 150566667 }
```

### 函数逻辑解释

1.  **计算总帧数 (`totalFrames`)**：这是关键的第一步。我们用原始时长计算出理论上包含多少帧（可能带小数），然后用 `Math.ceil()` **向上取整**。这是因为视频轨道的最小单位是帧，只要时长超出了整数帧，就必须占用下一个帧的“格子”。

2.  **计算轨道时长 (`timelineDurationInMicroseconds`)**：一旦我们确定了视频会占用 `N` 个帧，那么它在轨道上的新时长就与原始时长无关了。它被重新定义为 `N` 乘以**每一帧的精确时长**。
    *   在30 FPS下，每一帧的精确时长是 `1,000,000 / 30` 微秒。
    *   我们将 `totalFrames` 乘以这个单帧时长，就得到了它在剪映轨道上被量化后的最终时长。
    *   最后使用 `Math.round()` 来确保结果是一个整数微秒值。

这个函数现在可以准确地告诉您，一个任意时长的视频文件，在被放入剪映30FPS项目后，会占用多少帧，以及它的时长会变成多少。

---

您提出的观察非常敏锐，您是完全正确的！

非常感谢您提供了实际的测试数据，这让我能够纠正之前基于纯理论模型的回答。您的数据揭示了一个在软件工程中处理时间时非常普遍且重要的细节。

之前的函数是基于一个**理想化的数学模型**，即每一帧的时长都是 `1,000,000 / 30 = 33333.333...` 微秒。

而您的数据则展示了剪映**实际的工程实现**。由于微秒必须是整数，软件无法存储 `33333.333...`。如果每一帧都简单地取整为 `33333` 微秒，那么每30帧就会丢失10微秒，时间长了就会产生肉眼可见的误差和音画不同步。

### 剪映采用的“补偿算法”

为了解决这个问题，剪映（以及很多其他专业软件）采用了一种补偿模式。我们来分析您给出的数据：

*   第1帧时长: 33,333
*   第2帧时长: 66,666 - 33,333 = **33,333**
*   第3帧时长: 100,000 - 66,666 = **33,334**
*   第4帧时长: 133,333 - 100,000 = **33,333**
*   第5帧时长: 166,666 - 133,333 = **33,333**
*   第6帧时长: 200,000 - 166,666 = **33,334**

规律非常清晰：**它使用一个 `33333, 33333, 33334` 的重复序列。**
每3帧的总时长是 `33333 + 33333 + 33334 = 100,000` 微秒。
这3帧的平均时长就是 `100,000 / 3 = 33333.333...`，完美地吻合了理论值！

这是一种非常聪明的、用于在整数运算中逼近无限循环小数的常用方法。

### 修正后的 Node.js 函数

现在，我们必须编写一个函数来**精确模拟这个行为**。这个函数分为两步：
1.  根据原始时长，判断出它需要占用多少个帧位。
2.  根据占用的总帧数，利用 `33333, 33333, 33334` 的模式，计算出在轨道上精确的、被量化后的时长。

```javascript
/**
 * 根据视频的原始时长，精确模拟剪映30FPS轨道的量化行为，
 * 计算出映射后的总帧数和新时长。
 *
 * 该函数基于观测到的 (33333, 33333, 33334) 微秒/帧的重复模式。
 *
 * @param {number} originalDurationInMicroseconds 视频的原始实际时长，单位是微秒。
 * @returns {{totalFrames: number, timelineDurationInMicroseconds: number}} 一个包含总帧数和在轨道上的新时长的对象。
 */
function calculateJianyingTimelineMetrics(originalDurationInMicroseconds) {
  // --- 参数校验 ---
  if (typeof originalDurationInMicroseconds !== 'number' || originalDurationInMicroseconds < 0) {
    console.error("输入错误: 时长必须是一个非负数字。");
    return {
      totalFrames: 0,
      timelineDurationInMicroseconds: 0
    };
  }

  if (originalDurationInMicroseconds === 0) {
    return {
      totalFrames: 0,
      timelineDurationInMicroseconds: 0
    };
  }

  // --- 步骤 1: 估算并确定占用的总帧数 ---
  // 我们仍然使用平均帧率来做初步估算，以确定一个时长应该落入哪个帧的范畴。
  const FRAME_RATE = 30;
  const MICROSECONDS_IN_A_SECOND = 1000000;
  const averageFrameDuration = MICROSECONDS_IN_A_SECOND / FRAME_RATE;
  
  // 向上取整，因为只要多出一点点时间，就需要占用下一帧
  const totalFrames = Math.ceil(originalDurationInMicroseconds / averageFrameDuration);

  // --- 步骤 2: 基于总帧数，使用观测到的模式精确计算轨道时长 ---
  const numCycles = Math.floor(totalFrames / 3); // 计算有多少个完整的 (33333, 33333, 33334) 周期
  const remainingFrames = totalFrames % 3;     // 计算周期之外还剩几帧

  // 每个完整周期的时长是 100,000 微秒
  let timelineDurationInMicroseconds = numCycles * 100000;

  // 加上剩余帧的时长
  if (remainingFrames === 1) {
    timelineDurationInMicroseconds += 33333;
  } else if (remainingFrames === 2) {
    timelineDurationInMicroseconds += 66666; // 33333 + 33333
  }
  // 如果 remainingFrames 是 0, 说明正好是整周期，无需额外加。

  return {
    totalFrames,
    timelineDurationInMicroseconds
  };
}


// --- 使用您的数据进行验证 ---
console.log("--- 验证用户提供的数据 ---");
console.log(`第1帧: `, calculateJianyingTimelineMetrics(33333));   // 期望: { totalFrames: 1, timelineDurationInMicroseconds: 33333 }
console.log(`第2帧: `, calculateJianyingTimelineMetrics(66666));   // 期望: { totalFrames: 2, timelineDurationInMicroseconds: 66666 }
console.log(`第3帧: `, calculateJianyingTimelineMetrics(100000));  // 期望: { totalFrames: 3, timelineDurationInMicroseconds: 100000 }
console.log(`第9帧: `, calculateJianyingTimelineMetrics(300000));  // 期望: { totalFrames: 9, timelineDurationInMicroseconds: 300000 }
console.log(`第10帧: `, calculateJianyingTimelineMetrics(333333)); // 期望: { totalFrames: 10, timelineDurationInMicroseconds: 333333 }
console.log("---------------------------\n");


// --- 测试之前有问题的例子 ---
console.log("--- 测试边界情况 ---");

// 一个不能被整除的时长 (90,000 微秒)
// 90,000µs / (1,000,000/30)µs/帧 = 2.7 帧 => 向上取整为 3 帧。
// 3帧的时长按新算法是 100,000 µs
const metrics1 = calculateJianyingTimelineMetrics(90000);
console.log(`原始时长: 90,000 µs  =>`, metrics1); // 期望: { totalFrames: 3, timelineDurationInMicroseconds: 100000 }

// 比1秒多一点点
// 1,000,001µs / (1,000,000/30)µs/帧 = 30.00003 帧 => 向上取整为 31 帧。
// 31帧 = 10个周期 + 1个剩余帧。
// 10 * 100,000 + 33,333 = 1,033,333
const metrics2 = calculateJianyingTimelineMetrics(1000001);
console.log(`原始时长: 1,000,001 µs =>`, metrics2); // 期望: { totalFrames: 31, timelineDurationInMicroseconds: 1033333 }
```

### 新旧对比和总结

*   **旧模型（错误）**：假设每帧时长恒定为 `33333.333...`，导致计算结果与剪映实际情况有偏差。
*   **新模型（正确）**：通过分析您的实测数据，复刻了剪映 `33333, 33333, 33334` 的补偿模式，现在可以精确计算出任何原始时长在映射到剪映轨道后，所对应的帧数和被量化后的新时长。

再次感谢您的指正，这使得最终的解决方案更加精确和贴近实际应用！

